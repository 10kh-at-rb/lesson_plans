## Higher Order Ruby -- Programming with Blocks, Procs, and Lambdas

### Learning Goals

* Develop a mental model for what happens when we use a "block" in ruby
* Understand how to create new Proc and Lambda objects
* Understand how to call a Proc or Lambda
* Understand how to accept a block passed to your method and invoke it using `yield` and using the `&block` syntax
* Take a first sip from the cup of functional programming arcana

### Warmup -- Blocks, Procs, Lambdas -- OH MY

Discussion/Questions:

* In what context have you used Blocks in ruby code?
* What does a Block represent?
* Give 3 code snippets using a block
* What would these snippets look like __without__ a block?

### Terminology -- Blocks vs. Procs/Lambdas

* blocks -- part of language syntax
* a "Block" is really just a block of code -- technically a block just delineates a syntactically contained segment of source code
* "blocks" in ruby and blocks in other languages (Java, Javascript, etc)

**In Practice**

* However generally when people talk about "blocks" in ruby, they're actually talking about what happens when you pass
a block to a method
* example -- Square brackets vs array
* `Proc` -- Ruby object that is actually generated by a Block -- we'll see this later

### So what actually happens when we pass a block to a method?

Rules:

1. Ruby allows a Block to be passed to any method as an optional final argument
2. It's up to the methods implementation to determine how (or even if) to use the provided block

**Exercise**

1. Define a method `print_name(name)` which takes a name as an argument and prints it
2. Call that method using your name
3. Call that name using your name _AND_ a block of your choosing

What happened to the block you provided? Why does ruby not complain when you pass the block even though it's not being used?

### Using a block passed to your method

There are 2 ways to do this

#### 1. `yield` keyword


#### 1. `yield` keyword

### Proc by any other name

* Term `proc` comes from _proc_edure
* Tries to capture the idea of a proc as an actual process that is stored for later
* Other languages use other terms -- function, lambda, routine, functor

### Scope, local variables, and closures

* Recall how we describe an object: a collection of behavior combined with labels
* Procs have some similarities -- they bind a chunk of code to a collection of local variables; we call this collection of variables a "lexical context"

Block scope example. Ever wonder why this works?

```ruby
x = 5

def method_cant_see_surrounding_local_vars
  puts x
end

5.times do
  puts "but procs can #{x}"
end
```

So where does a block's lexical context come from?

* bindings -- objects' way of tracking local variable context
* when we create a new block, it takes on the binding of the context in which it was created.
* this lets a block share (and update -- more on that in a second) the local variables that were defined in the context _in which it was created_.
* This behavior is what we describe as a _closure_ -- we say the block "closes over" the local variables, allowing it to take them with it
* Closures are portable just like procs -- even if we pass the proc off to another method or place in code, it maintains its ability to access those local variables that were defined in the context that created it.

## TODO -- proc closure examples

### Procs vs Lambdas

* lambdas basically a subtype of proc
* only 2 differences

1. Lambdas are strict about their number of arguments (fancy CS word -- arity)
2. `return` keyword -- in a lambda this will return only from the local context i.e the block itself; in a proc this will return from the surrounding method context

### Using procs in your own methods

* rubyists _create_ and pass blocks all the time -- e.g. every time you use an enumerable
* but not many people actually write code that _accepts_ blocks
* even though ruby has great support for this type of programming (and it can be used to do powerful things) it's not a very common part of the languages style

### Higher-Order Functions

* Term in programming for functions (methods) that take other methods as arguments
* design pattern -- allows us to generalize a common process in a way that users (other programmers) can very flexibly customize it to fit their various problems

For example `map` -- this method represents the _idea_ of using some process (the block) to transform a collection of values into a new collection

We could hard code this in the standard way:

```ruby
nums = [1,2,3,4]
i = 0
doubles = []
while i < nums.length
  doubles << nums[i] * 2
  i += 1
end

doubles
=> [2,4,6,8]
```

What could be improved about this code?

The pieces are rigidly connected together
